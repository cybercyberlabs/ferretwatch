class BackgroundService{constructor(){this.tabResults=new Map,this.apiEndpoints=new Map,this.settings=null,this.requestHeadersCache=new Map,this.init()}init(){console.log("üîß Background service worker initializing..."),this.setupMessageListeners(),this.setupStorageListeners(),this.setupTabListeners(),this.loadSettings().then((()=>{console.log("‚úÖ Background service worker ready")}))}async loadSettings(){try{const e="undefined"!=typeof browser?browser:chrome,t=await e.storage.local.get("userSettings");this.settings=t.userSettings||this.getDefaultSettings()}catch(e){console.error("Failed to load settings:",e),this.settings=this.getDefaultSettings()}}getDefaultSettings(){return{enabledCategories:["aws","github","api-keys","databases","certificates"],riskThreshold:"medium",enableNotifications:!0,enableHighlighting:!1,enableSoundAlerts:!1,scanDelay:1e3,trustedDomains:[],cloudBucketScanning:{enabled:!0,providers:{aws:!0,gcp:!0,azure:!0,digitalocean:!0,alibaba:!0},testTimeout:5e3,maxConcurrentTests:3,testPublicAccess:!0}}}setupMessageListeners(){chrome.runtime.onMessage.addListener(((e,t,s)=>(this.handleMessage(e,t,s),!0)))}async handleMessage(e,t,s){try{switch(e.type){case"SCAN_COMPLETE":await this.handleScanComplete(e.data,t.tab?.id),s({success:!0});break;case"GET_SETTINGS":s({settings:this.settings});break;case"UPDATE_SETTINGS":await this.updateSettings(e.data),s({success:!0});break;case"GET_TAB_RESULTS":const o=undefined;s({results:this.tabResults.get(t.tab?.id)||[]});break;case"CLEAR_TAB_RESULTS":this.tabResults.delete(t.tab?.id),s({success:!0});break;case"EXPORT_SESSION_DATA":const r=undefined;s({data:await this.getSessionData()});break;case"SHOW_NOTIFICATION":await this.showNotification(e.data),s({success:!0});break;case"API_CALL_CAPTURED":this.handleApiCall(e.data,t.tab?.id,t.tab?.url),s({success:!0});break;case"API_RESPONSE_CAPTURED":this.handleApiResponse(e.data,t.tab?.id),s({success:!0});break;case"REPLAY_REQUEST":return this.replayRequest(e.data).then(s),!0;case"PROXY_REQUEST":return this.handleProxyRequest(e.data,e.tabId).then(s),!0;case"GET_API_ENDPOINTS":const n=undefined;s({endpoints:this.apiEndpoints.get(e.tabId)||[]});break;case"CLEAR_API_ENDPOINTS":this.apiEndpoints.set(e.tabId,[]),s({success:!0});break;case"SCAN_UNUSED_ENDPOINTS":return this.handleUnusedEndpointScan(e.tabId,t.tab?.id).then(s),!0;default:console.warn("Unknown message type:",e.type),s({error:"Unknown message type"})}}catch(e){console.error("Error handling message:",e),s({error:e.message})}}async handleScanComplete(e,t){if(!t)return;const s=undefined,o=[...this.tabResults.get(t)||[],...e.findings];if(this.tabResults.set(t,o),this.settings.enableNotifications){const t=e.findings.filter((e=>"critical"===e.riskLevel||"high"===e.riskLevel));t.length>0&&await this.showNotification({type:"credential_detected",title:"üö® Credentials Detected",message:`Found ${t.length} high-risk credential(s)`,findings:t})}await this.updateBadge(t,o.length)}handleApiCall(e,t,s){if(!t)return void console.warn("[API] No tabId provided for API call:",e.url);if(console.log(`[API] Storing endpoint for tab ${t}: ${e.method} ${e.url}`),s)try{e.origin=new URL(s).origin}catch(e){console.warn("[API] Could not parse tab URL for origin:",s)}const o=this.apiEndpoints.get(t)||[],r=undefined;if(!o.some((t=>t.method===e.method&&t.url===e.url))){const s=`${e.method}:${e.url}`,r=this.requestHeadersCache.get(s);if(console.log(`üîç [API] Looking for cached headers: ${s}`),console.log(`üîç [API] Cache has entry: ${!!r}`),console.log(`üîç [API] Current cache size: ${this.requestHeadersCache.size}`),r){const t=Object.keys(e.headers||{}).some((e=>"cookie"===e.toLowerCase()));e.headers={...e.headers,...r};const o=Object.keys(e.headers).some((e=>"cookie"===e.toLowerCase()));console.log(`‚úÖ [API] Merged headers from webRequest for ${s}`),console.log(`üç™ [API] Cookie before merge: ${t}, after merge: ${o}`),this.requestHeadersCache.delete(s)}else console.log(`‚ö†Ô∏è [API] No cached headers found for ${s} - may have timed out or not captured yet`);e.source="live",e.response=null,o.push(e),this.apiEndpoints.set(t,o),this.notifyExplorerTabs(t,e)}}handleApiResponse(e,t){if(!t)return void console.warn("[API] No tabId provided for API response:",e.url);console.log(`[API] Received response for tab ${t}: ${e.status} ${e.method} ${e.url}`);const s=this.apiEndpoints.get(t)||[],o=s.find((t=>t.method===e.method&&t.url===e.url));if(o)o.response={status:e.status,statusText:e.statusText,responseHeaders:e.responseHeaders,responseBody:e.responseBody,responseSize:e.responseSize,duration:e.duration,error:e.error},this.apiEndpoints.set(t,s),this.notifyExplorerTabs(t,o),console.log("‚úÖ [API] Updated endpoint with response data");else{console.warn(`‚ö†Ô∏è [API] No matching request found for response: ${e.method} ${e.url}`);const o={method:e.method,url:e.url,type:e.type,timestamp:e.timestamp,headers:{},body:null,source:"live",response:{status:e.status,statusText:e.statusText,responseHeaders:e.responseHeaders,responseBody:e.responseBody,responseSize:e.responseSize,duration:e.duration,error:e.error}};s.push(o),this.apiEndpoints.set(t,s),this.notifyExplorerTabs(t,o)}}async replayRequest(e){console.log(`[API] Replaying request: ${e.method} ${e.url}`),console.log(`[API] Request origin: ${e.origin||"NOT SET"}`),console.log("[API] Full request data:",e);const t=Date.now();try{let s=e.url;if(!e.origin||e.url.startsWith("http://")||e.url.startsWith("https://"))e.url.startsWith("http://")||e.url.startsWith("https://")||(console.warn(`[API] ‚ö†Ô∏è Relative URL detected but NO ORIGIN SET: ${e.url}`),console.warn("[API] This will cause a NetworkError. Origin should have been stored when request was captured."));else try{s=new URL(e.url,e.origin).href,console.log(`[API] Resolved relative URL: ${e.url} -> ${s}`)}catch(t){console.warn("[API] Could not resolve relative URL:",e.url,t)}console.log(`[API] Final URL to fetch: ${s}`);const o=await fetch(s,{method:e.method,headers:e.headers||{},body:e.body||null,credentials:"omit",mode:"cors"}),r=Date.now()-t,n=await o.text(),a={};for(const[e,t]of o.headers.entries())a[e]=t;return console.log(`‚úÖ [API] Request completed: ${o.status} in ${r}ms`),{success:!0,status:o.status,statusText:o.statusText,headers:a,body:n,duration:r}}catch(e){const s=Date.now()-t;return console.error("‚ùå [API] Request failed:",e),{success:!1,error:e.message,duration:s}}}cacheRequestHeaders(e,t,s){const o=`${e}:${t}`,r={};Array.isArray(s)&&s.forEach((e=>{r[e.name]=e.value}));const n=Object.keys(r).some((e=>"cookie"===e.toLowerCase()));console.log(`üì¶ [CACHE] Storing headers for ${o} - Cookie present: ${n}`),n&&console.log(`üç™ [CACHE] Cookie value: ${r.Cookie||r.cookie}`),this.requestHeadersCache.set(o,r),setTimeout((()=>{this.requestHeadersCache.delete(o)}),5e3)}async handleUnusedEndpointScan(e,t){const s=e||t;if(!s)return{success:!1,error:"No target tab specified"};try{console.log(`üîç [Background] Starting unused endpoint scan for tab ${s}`);const e="undefined"!=typeof browser?browser:chrome,t=await e.tabs.sendMessage(s,{action:"scanUnusedEndpoints"});if(!t||!t.success)return{success:!1,error:t?.error||"Scan failed"};console.log(`‚úÖ [Background] Scan complete. Found ${t.total} potential endpoints`);const o=this.apiEndpoints.get(s)||[],r=new Set(o.map((e=>{try{const t=new URL(e.url);return t.origin+t.pathname}catch{return e.url}}))),n=t.discovered.filter((e=>{const t=e.normalizedUrl||e.url;return!r.has(t)})),a=t.discovered.filter((e=>{const t=e.normalizedUrl||e.url;return r.has(t)}));console.log(`üìä [Background] Analysis: ${n.length} unused, ${a.length} used`);let i=null;try{const t=await e.tabs.get(s);t&&t.url&&(i=new URL(t.url).origin,console.log(`üåê [Background] Tab origin for URL resolution: ${i}`))}catch(e){console.warn("[Background] Could not get tab URL for origin:",e)}const c=undefined;return{success:!0,discovered:t.discovered.map((e=>({...e,origin:i}))),unused:n,used:a,stats:{totalDiscovered:t.total,totalCalled:o.length,totalUnused:n.length,totalUsed:a.length},scannedAt:t.scannedAt}}catch(e){return console.error("‚ùå [Background] Unused endpoint scan failed:",e),{success:!1,error:e.message}}}async notifyExplorerTabs(e,t){try{const s=await("undefined"!=typeof browser?browser:chrome).tabs.query({});for(const o of s)o.url&&(o.url.includes("popup/explorer.html")||o.url.includes("popup/explorer-v2.html"))&&o.url.includes(`tabId=${e}`)&&("undefined"!=typeof browser?browser:chrome).tabs.sendMessage(o.id,{type:"NEW_API_ENDPOINT",tabId:e,endpoint:t}).catch((e=>{console.debug("Could not notify explorer tab:",e.message)}))}catch(e){console.error("Error notifying explorer tabs:",e)}}async handleProxyRequest(e,t){try{console.log("üîÑ [Background] Forwarding proxy request to Content Script"),console.log("üîÑ [Background] Request data:",e),console.log("üîÑ [Background] Target tab ID:",t);const s="undefined"!=typeof browser?browser:chrome;let o;if(t)try{o=await s.tabs.get(t),console.log("‚úÖ [Background] Found specified tab:",o.id,o.url)}catch(e){console.warn(`‚ö†Ô∏è [Background] Specified tab ${t} not found:`,e.message)}if(!o){const e=await s.tabs.query({active:!0,currentWindow:!0});if(!e||0===e.length)throw console.error("‚ùå [Background] No active tab found"),new Error("No active tab found to execute request");o=e[0],console.log("üìç [Background] Using active tab:",o.id,o.url)}if(console.log(`üéØ [Background] Target Tab: ID=${o.id}, URL=${o.url}`),o.url.startsWith("chrome://")||o.url.startsWith("edge://")||o.url.startsWith("about:")||o.url.startsWith("moz-extension://"))throw console.warn("‚ö†Ô∏è [Background] Target tab is a restricted page. Content script likely missing."),new Error("Cannot inject content script into restricted page");const r=async()=>{console.log("üì§ [Background] Sending executeRequest to tab",o.id);const t=await s.tabs.sendMessage(o.id,{action:"executeRequest",data:e});return console.log("üì• [Background] Received response from content script:",t),t};try{const e=await r();return console.log("‚úÖ [Background] Proxy request successful"),e}catch(e){console.error("‚ùå [Background] sendMessage failed:",e.message);const t=undefined;if(!(e.message.includes("Receiving end does not exist")||e.message.includes("Could not establish connection"))||o.url.startsWith("about:")||o.url.startsWith("chrome"))throw e;{console.log("‚ö†Ô∏è [Background] Content script disconnected. Attempting lazy injection...");const e=["config/patterns.js","utils/storage.js","utils/context.js","utils/bucket-parser.js","utils/bucket-tester.js","utils/settings.js","utils/scanner.js","content.js"];for(const t of e)try{console.log(`üíâ [Background] Injecting ${t}...`),s.scripting?await s.scripting.executeScript({target:{tabId:o.id},files:[t]}):await s.tabs.executeScript(o.id,{file:t})}catch(e){console.error(`‚ùå [Background] Failed to inject ${t}:`,e)}await new Promise((e=>setTimeout(e,500))),console.log("üîÑ [Background] Retrying proxy request after injection...");const t=await r();return console.log("‚úÖ [Background] Retry successful"),t}}}catch(e){return console.error("‚ùå [Background] Proxy forwarding failed:",e),{success:!1,error:`Proxy Error: ${e.message}`}}}async updateSettings(e){const t=this.validateSettings(e);this.settings={...this.settings,...t};try{await chrome.storage.local.set({userSettings:this.settings});const e=await chrome.tabs.query({});for(const t of e)try{await chrome.tabs.sendMessage(t.id,{type:"SETTINGS_UPDATED",data:this.settings})}catch(e){}}catch(e){throw console.error("Failed to save settings:",e),e}}validateSettings(e){const t={...e};if(t.cloudBucketScanning){const e=t.cloudBucketScanning;if("boolean"!=typeof e.enabled&&(e.enabled=!0),e.providers&&"object"==typeof e.providers){const t=undefined;["aws","gcp","azure","digitalocean","alibaba"].forEach((t=>{"boolean"!=typeof e.providers[t]&&(e.providers[t]=!0)}))}else e.providers={aws:!0,gcp:!0,azure:!0,digitalocean:!0,alibaba:!0};("number"!=typeof e.testTimeout||e.testTimeout<1e3||e.testTimeout>3e4)&&(e.testTimeout=5e3),("number"!=typeof e.maxConcurrentTests||e.maxConcurrentTests<1||e.maxConcurrentTests>10)&&(e.maxConcurrentTests=3),"boolean"!=typeof e.testPublicAccess&&(e.testPublicAccess=!0)}return t}async showNotification(e){if(!this.settings.enableNotifications)return;const t={type:"basic",iconUrl:chrome.runtime.getURL("icons/icon-48.png"),title:e.title||"Credential Scanner",message:e.message||"Credentials detected",priority:e.findings?.some((e=>"critical"===e.riskLevel))?2:1};try{const e=await chrome.notifications.create(t);setTimeout((()=>{chrome.notifications.clear(e)}),5e3)}catch(e){console.error("Failed to show notification:",e)}}async updateBadge(e,t){const s=t>0?t.toString():"",o=t>0?"#dc3545":"#28a745";try{await chrome.browserAction.setBadgeText({text:s,tabId:e}),await chrome.browserAction.setBadgeBackgroundColor({color:o,tabId:e})}catch(e){console.error("Failed to update badge:",e)}}setupStorageListeners(){chrome.storage.onChanged.addListener(((e,t)=>{"local"===t&&e.userSettings&&(this.settings=e.userSettings.newValue,console.log("Settings updated from storage"))}))}setupTabListeners(){chrome.tabs.onRemoved.addListener((e=>{this.tabResults.delete(e),this.apiEndpoints.delete(e)})),chrome.tabs.onUpdated.addListener(((e,t)=>{"loading"===t.status&&(this.tabResults.delete(e),this.apiEndpoints.delete(e),this.updateBadge(e,0))}))}async getSessionData(){const e=[];for(const[t,s]of this.tabResults.entries())try{const o=await chrome.tabs.get(t);e.push({tabId:t,url:o.url,title:o.title,findings:s,timestamp:Date.now()})}catch(e){}return{sessionId:Date.now().toString(),exportDate:(new Date).toISOString(),totalFindings:e.reduce(((e,t)=>e+t.findings.length),0),totalTabs:e.length,settings:this.settings,tabs:e}}}class ChromeAPIAdapter{static adaptFirefoxToChrome(){"undefined"==typeof browser&&"undefined"!=typeof chrome&&(window.browser={runtime:{sendMessage:chrome.runtime.sendMessage.bind(chrome.runtime),onMessage:chrome.runtime.onMessage,getURL:chrome.runtime.getURL.bind(chrome.runtime)},storage:{local:{get:e=>new Promise((t=>chrome.storage.local.get(e,t))),set:e=>new Promise((t=>chrome.storage.local.set(e,t)))},onChanged:chrome.storage.onChanged},tabs:{query:e=>new Promise((t=>chrome.tabs.query(e,t))),sendMessage:(e,t)=>new Promise((s=>chrome.tabs.sendMessage(e,t,s)))},notifications:{create:e=>new Promise((t=>chrome.notifications.create(e,t))),clear:chrome.notifications.clear.bind(chrome.notifications)}})}}function isChromeExtension(){return"undefined"!=typeof chrome&&chrome.runtime&&chrome.runtime.id}function getExtensionAPI(){if("undefined"!=typeof browser)return browser;if("undefined"!=typeof chrome)return ChromeAPIAdapter.adaptFirefoxToChrome(),browser;throw new Error("No extension API available")}self.addEventListener("install",(e=>{console.log("üîß Service worker installing..."),self.skipWaiting()})),self.addEventListener("activate",(e=>{console.log("‚úÖ Service worker activated"),e.waitUntil(clients.claim())}));const activeProxyTargets=new Set;self.activeProxyTargets=activeProxyTargets,function(){try{const e=undefined,t=("undefined"!=typeof browser?browser:chrome).webRequest||("undefined"!=typeof chrome?chrome.webRequest:null);t&&t.onBeforeSendHeaders?(console.log("‚úÖ [TOP-LEVEL] Setting up webRequest listeners"),t.onBeforeSendHeaders.addListener((e=>{if(e.url.startsWith("chrome-extension://")||e.url.startsWith("moz-extension://"))return;if("xmlhttprequest"!==e.type&&"fetch"!==e.type&&"other"!==e.type)return void console.log(`‚è≠Ô∏è [HEADERS] Skipping non-API request type: ${e.type} for ${e.url}`);console.log(`üéØ [HEADERS] Intercepted ${e.type} request: ${e.method} ${e.url}`);const t=e.requestHeaders?.some((e=>"cookie"===e.name.toLowerCase()));console.log(`üç™ [HEADERS] Cookie present in webRequest: ${t}`),backgroundService&&backgroundService.cacheRequestHeaders?(backgroundService.cacheRequestHeaders(e.method,e.url,e.requestHeaders),console.log(`üì¶ [HEADERS] Cached headers for ${e.method} ${e.url}`)):console.warn("‚ö†Ô∏è [HEADERS] backgroundService not available!")}),{urls:["<all_urls>"]},"undefined"!=typeof browser?["requestHeaders"]:["requestHeaders","extraHeaders"]),t.onBeforeSendHeaders.addListener((e=>{let t=!1;const s=e.requestHeaders||[];for(let o=0;o<s.length;o++)if("X-FW-Proxy"===s[o].name){t=!0,s.splice(o,1),console.log("üéØ [PROXY] Intercepted request with marker:",e.url);break}const o=activeProxyTargets.has(e.url);if(t||o){const r=new URL(e.url),n=r.origin;o&&!t&&console.log(`üîé [PROXY] Intercepted Preflight/Related request: ${e.method} ${e.url}`);let a=!1;for(const e of s)"origin"===e.name.toLowerCase()?(console.log(`üîÑ [PROXY] Rewriting Origin: ${e.value} -> ${n}`),e.value=n,a=!0):"referer"===e.name.toLowerCase()&&(console.log(`üîÑ [PROXY] Rewriting Referer: ${e.value} -> ${r.href}`),e.value=r.href);return a||(console.log(`‚ûï [PROXY] Adding Origin: ${n}`),s.push({name:"Origin",value:n}),s.some((e=>"referer"===e.name.toLowerCase()))||s.push({name:"Referer",value:r.href})),{requestHeaders:s}}}),{urls:["<all_urls>"]},"undefined"!=typeof browser?["blocking","requestHeaders"]:["blocking","requestHeaders","extraHeaders"])):console.error("‚ùå [TOP-LEVEL] webRequest API not available!")}catch(e){console.error("‚ùå [TOP-LEVEL] CRITICAL ERROR during webRequest setup:",e)}}();let backgroundService=null;try{backgroundService=new BackgroundService}catch(e){console.error("‚ùå Failed to initialize background service:",e)}chrome.runtime.onStartup.addListener((()=>{console.log("üöÄ Extension startup"),backgroundService||(backgroundService=new BackgroundService)})),chrome.runtime.onInstalled.addListener((e=>{console.log("üì¶ Extension installed/updated:",e.reason),backgroundService||(backgroundService=new BackgroundService)})),"undefined"!=typeof module&&module.exports&&(module.exports={BackgroundService:BackgroundService,ChromeAPIAdapter:ChromeAPIAdapter});